# Problem statement
# You are given a stream of 'N' integers. For every 'i-th' integer added to the running list of integers, 
# print the resulting median.
# Print only the integer part of the median.
# Sample Input 1 :
# 6
# 6 2 1 3 7 5
# Sample Output 1 :
# 6 4 2 2 3 4
# Explanation of Sample Output 1 :
# S = {6}, median = 6
# S = {6, 2} -> {2, 6}, median = 4
# S = {6, 2, 1} -> {1, 2, 6}, median = 2
# S = {6, 2, 1, 3} -> {1, 2, 3, 6}, median = 2
# S = {6, 2, 1, 3, 7} -> {1, 2, 3, 6, 7}, median = 3
# S = {6, 2, 1, 3, 7, 5} -> {1, 2, 3, 5, 6, 7}, median = 4
# Sample Input 2 :
# 5
# 5 4 3 2 1
# Sample Output 2 :
# 5 4 4 3 3
// Anuj Bhaiya = https://www.youtube.com/watch?v=Yv2jzDzYlp8
#include<queue>
void findMedian(int *arr, int n)
{ 
   priority_queue<int> max_heap;
   priority_queue<int, vector<int>, greater<int>> min_heap;

    for(int i=0; i<n; i++){
        // Insertion step
        int num = arr[i];
        if(max_heap.empty() || max_heap.top() > num){
            max_heap.push(num);
        }
        else {
            min_heap.push(num);
        }

        // balancing step
        // max heap size either should be equal to min heap or should not be greater then min_heap_size+1
        if(max_heap.size() > min_heap.size()+1){
            int top = max_heap.top();
            max_heap.pop();
            min_heap.push(top);
        }
        else if(max_heap.size() < min_heap.size()){
            int top = min_heap.top();
            min_heap.pop();
            max_heap.push(top);
        }

        // find median step
        if(max_heap.size() == min_heap.size()){
            int top1 = max_heap.top();
            int top2 = min_heap.top();
            cout<<(top1+top2)/2<<" ";
        }
        else {
            cout<<max_heap.top()<<" ";
        }


    }
}
